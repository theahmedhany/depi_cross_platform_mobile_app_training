# 📘 Week 3: Comprehensive Dart Programming Guide - From Fundamentals to Advanced OOP.

This comprehensive guide covers essential Dart programming concepts from basic syntax and null safety to advanced object-oriented programming principles. Perfect for developers building a solid foundation in Dart!

---

## 🎯 Task 1: Variables and Null Safety Fundamentals

### 📋 Description:

Create variables of different types (String, int, double, bool, List, Map) and practice null safety with nullable variables.

### ✅ Objective:

Master Dart's type system and null safety features while getting comfortable with basic syntax.

### 📥 Input:

Hardcoded values demonstrating different data types and null handling.

### 🧠 Implementation Logic:

Demonstrate variable declaration, initialization, and null safety using the null coalescing operator.

### 💡 Key Concepts:

- **Variable Types**: String, int, double, bool, List, Map
- **Null Safety**: Using `?` for nullable types
- **Null Coalescing**: `??` operator for default values
- **String Interpolation**: `${}` syntax for embedding expressions
- **Collection Types**: List and Map initialization

> 🚀 _This task introduces Dart's robust type system and null safety features._

---

## 🎯 Task 2: Class Definition and Object Creation

### 📋 Description:

Define a Book class with properties (title, author, year, rating), constructor, and methods while practicing null safety with optional properties.

### ✅ Objective:

Learn class definition, constructors, and method implementation with null safety considerations.

### 📥 Input:

Book details with nullable rating property for demonstration.

### 🧠 Implementation Logic:

Create a complete class with constructor parameter initialization and a method that handles nullable properties gracefully.

### 💡 Key Concepts:

- **Class Definition**: Properties and methods
- **Constructor**: Parameter initialization with `this.`
- **Nullable Properties**: Using `?` for optional values
- **Method Implementation**: Void methods for actions
- **Null Handling**: Safe display of nullable values

> 🎯 _Perfect for understanding basic OOP concepts in Dart._

---

## 🎯 Task 3: Multiple Objects and Class Interaction

### 📋 Description:

Create a Student class and instantiate multiple objects to demonstrate class reusability and object independence.

### ✅ Objective:

Practice creating multiple instances of a class and calling methods on different objects.

### 📥 Input:

Multiple student records with name, age, and marks.

### 🧠 Implementation Logic:

Demonstrate how the same class blueprint can create multiple independent objects with different data.

### 💡 Key Concepts:

- **Object Instantiation**: Creating multiple instances
- **Method Calls**: Invoking methods on different objects
- **Data Encapsulation**: Organizing related data and behavior
- **Instance Independence**: Each object maintains its own state

> 🔥 _Demonstrates the power of classes for creating reusable code structures._

---

## 🎯 Task 4: OOP Knowledge Assessment

### 📋 Description:

Comprehensive quiz covering fundamental to advanced OOP concepts in Dart including classes, inheritance, mixins, and polymorphism.

### ✅ Objective:

Test understanding of Dart's object-oriented programming features through multiple-choice questions.

### 📥 Input:

15 carefully crafted questions with correct answers marked.

### 🧠 Implementation Logic:

Progressive difficulty from basic class concepts to advanced OOP principles.

### 🔍 Topics Covered:

- **Class Fundamentals**: Definition and purpose
- **Constructor Types**: Default, named, and factory constructors
- **Inheritance**: `extends` keyword and `super` usage
- **Mixins**: Code reuse and restrictions
- **Polymorphism**: Method overriding and dynamic dispatch
- **Interfaces**: `implements` vs `extends`
- **Abstract Classes**: Purpose and implementation requirements

### 💡 Key Concepts:

- **Assessment Strategy**: Multiple choice format
- **Comprehensive Coverage**: All major OOP concepts
- **Practical Examples**: Code-based questions
- **Answer Validation**: Correct answers clearly marked

> 🧠 _Essential knowledge check for OOP mastery in Dart._

---

## 🎯 Task 5: Basic Class and Object Creation

### 📋 Description:

Create a simple Book class with title and author properties, demonstrating basic class structure and object instantiation.

### ✅ Objective:

Master the fundamentals of class definition and object creation with minimal complexity.

### 📥 Input:

Simple book information (title and author).

### 🧠 Implementation Logic:

Focus on clean class definition with constructor and a single method for displaying information.

### 💡 Key Concepts:

- **Class Basics**: Properties and methods
- **Constructor Simplicity**: Direct parameter assignment
- **Method Implementation**: Single responsibility principle
- **Object Creation**: Basic instantiation pattern

> 🎯 _Foundation building block for object-oriented programming._

---

## 🎯 Task 6: Constructor Practice

### 📋 Description:

Create a Student class focusing on constructor usage and the `this` keyword for parameter assignment.

### ✅ Objective:

Understand constructor mechanics and parameter handling in Dart classes.

### 📥 Input:

Student information (name and grade).

### 🧠 Implementation Logic:

Demonstrate proper constructor syntax and parameter initialization using `this` keyword.

### 💡 Key Concepts:

- **Constructor Syntax**: Parameter declaration and assignment
- **`this` Keyword**: Distinguishing between parameters and properties
- **Method Naming**: Descriptive method names
- **Information Display**: Formatted output techniques

> ⚡ _Critical for understanding how constructors work in Dart._

---

## 🎯 Task 7: Named Constructor Implementation

### 📋 Description:

Create a User class with a named constructor that provides default values for guest users.

### ✅ Objective:

Master named constructors and their use cases for creating objects with specific configurations.

### 📥 Input:

Default guest user configuration.

### 🧠 Implementation Logic:

Implement alternative constructor using initializer list syntax for setting default values.

### 💡 Key Concepts:

- **Named Constructors**: Alternative object creation methods
- **Initializer Lists**: Using `:` syntax for property initialization
- **Default Values**: Providing sensible defaults
- **Constructor Overloading**: Multiple ways to create instances

> 🚀 _Essential for providing flexible object creation patterns._

---

## 🎯 Task 8: Basic Inheritance

### 📋 Description:

Create a base Vehicle class and extend it with a Car subclass to demonstrate inheritance relationships.

### ✅ Objective:

Understand inheritance relationships and method access in subclasses.

### 📥 Input:

Base vehicle functionality and specific car behaviors.

### 🧠 Implementation Logic:

Demonstrate how subclasses inherit methods from parent classes while adding their own functionality.

### 💡 Key Concepts:

- **Inheritance**: `extends` keyword for class hierarchy
- **Method Inheritance**: Access to parent class methods
- **Code Reusability**: Sharing common functionality
- **Class Hierarchy**: Building logical relationships

> 🔥 _Foundation for building hierarchical class structures._

---

## 🎯 Task 9: Constructor Inheritance

### 📋 Description:

Create Animal and Cat classes demonstrating constructor chaining with the super keyword.

### ✅ Objective:

Master constructor inheritance and parameter passing to parent classes.

### 📥 Input:

Animal name and cat-specific age information.

### 🧠 Implementation Logic:

Show how subclass constructors can call parent constructors using `super()` while adding their own parameters.

### 💡 Key Concepts:

- **Constructor Chaining**: Using `super()` to call parent constructor
- **Parameter Passing**: Forwarding arguments to parent class
- **Inheritance Hierarchy**: Building complex object relationships
- **Property Access**: Using inherited properties in subclasses

> 🎯 _Critical for understanding how constructors work in inheritance._

---

## 🎯 Task 10: Abstract Classes

### 📋 Description:

Create an abstract Shape class and implement it with a concrete Square class.

### ✅ Objective:

Learn abstract classes and method implementation requirements.

### 📥 Input:

Square dimensions for area calculation.

### 🧠 Implementation Logic:

Demonstrate how abstract classes define contracts that concrete classes must implement.

### 💡 Key Concepts:

- **Abstract Classes**: Cannot be instantiated directly
- **Method Signatures**: Defining contracts for subclasses
- **@override Annotation**: Explicit method overriding
- **Implementation Requirements**: Forcing subclasses to implement methods
- **Polymorphism**: Same interface, different implementations

> 🚀 _Essential for creating contracts and ensuring consistent interfaces._

---

## 🎯 Task 11: Mixins Fundamentals

### 📋 Description:

Create a Printer mixin and use it in a Document class to demonstrate code reuse without inheritance.

### ✅ Objective:

Understand mixins as a way to share functionality across classes.

### 📥 Input:

Document printing functionality demonstration.

### 🧠 Implementation Logic:

Show how mixins provide horizontal code reuse, allowing classes to gain functionality without inheritance.

### 💡 Key Concepts:

- **Mixins**: Reusable code blocks
- **`with` Keyword**: Applying mixins to classes
- **Horizontal Code Reuse**: Sharing functionality without inheritance
- **Composition**: Building functionality from components

> 🔥 _Perfect for adding capabilities to classes without complex inheritance._

---

## 🎯 Task 12: Multiple Mixins

### 📋 Description:

Create Logger and Saver mixins and combine them in an App class to demonstrate multiple mixin usage.

### ✅ Objective:

Master combining multiple mixins for enhanced functionality.

### 📥 Input:

Multiple application behaviors (logging and saving).

### 🧠 Implementation Logic:

Demonstrate how a single class can incorporate multiple mixins, gaining all their methods and properties.

### 💡 Key Concepts:

- **Multiple Mixins**: Combining several mixins
- **Method Access**: Using methods from all mixed-in classes
- **Composition**: Building complex functionality from simple parts
- **Mixin Order**: Understanding how multiple mixins interact

> ⚡ _Demonstrates the power of mixins for modular design._

---

## 🎯 Task 13: Polymorphism

### 📋 Description:

Create Animal, Dog, and Cat classes to demonstrate polymorphic behavior through method overriding.

### ✅ Objective:

Understand polymorphism and method overriding for dynamic behavior.

### 📥 Input:

Collection of different animal types.

### 🧠 Implementation Logic:

Show how the same method call can produce different behaviors depending on the actual object type at runtime.

### 💡 Key Concepts:

- **Polymorphism**: Same interface, different implementations
- **Method Overriding**: Redefining parent class methods
- **Dynamic Dispatch**: Runtime method resolution
- **Collections**: Working with polymorphic object collections
- **List Iteration**: Processing heterogeneous collections

> 🎯 _Core concept for flexible and extensible code design._

---

## 🎯 Task 14: Interface Implementation

### 📋 Description:

Create a PrinterInterface and implement it in a Report class to demonstrate interface contracts.

### ✅ Objective:

Learn interface contracts and the implements keyword.

### 📥 Input:

Report generation functionality.

### 🧠 Implementation Logic:

Show how classes can implement interfaces to guarantee they provide specific methods.

### 💡 Key Concepts:

- **Interface Implementation**: Using `implements` keyword
- **Contract Fulfillment**: Implementing all required methods
- **Multiple Interfaces**: Classes can implement multiple interfaces
- **Type Safety**: Ensuring consistent method signatures
- **API Design**: Creating consistent interfaces

> 🚀 _Essential for creating robust, contract-based architectures._

---
